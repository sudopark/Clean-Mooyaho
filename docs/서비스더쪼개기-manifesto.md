### 개선할 사항
- 현재 UI단은 대표 피처별로 분리되어 있지만 Domain, DataStore의 경우 점점 비대해짐을 피할수은 없다
- 저수준의 UI 프레임 워크와 datastore가 고수준인 domain 만바라보는 구조이지만 거대한 domain framework의 의존이 크다
- domain의 특정 usecase 들은 이미 복잡도가 매우 높다 -> 더 작은 인스턴스들의 협업관계로 나누어야 할 필요가 있음
- datastore내 repository들의 구현(local or remote)의 복잡도가 매우 높다, 데이터베이스 스위칭 로직이 매우 복잡하다, local을 사용하는 경우 repository-local-dataModelStorage로 이어지는 스파게티 코드가 심하다
- 그래도 대부분의 vm들의 역할들은 usecase로 옮겨가져 있어 어느정도 복잡도가 해소되었다.
- 별도 서비스간 entity의 의존도가 높다(각 특성에 따라 정의되어있지 않음)
- presentation layer에 속한 컴포넌트들의 접근제한자가 불필요하게 public이다 -> 프레임워크별 빌드속도 최적화 저하
- 조회, 아이템의 속성 변경 등의 로직들이 앱의 구현에 필요한 세부사항 객체들 위주로 구현되어있다 -> 도메인 모델이 아님

### 방향
- domain을 비즈니스 능력(서비스 특성)에 맞추어 여러 서비스로 나눈다.
- 각 서비스는 별도의 저장소를 지닐 수 있다 -> 서로 각자 다른 remote, local 구현
- 각 서비스는 필요한 고유 entity를 정의한다.
- 각각의 서비스는 직접적으로 참조하지 않고 느슨한 협업 관계를 유지한다.
- 앱 타겟에 있는 ui 로직들을 포함하여 presentation layer간 분류를 화면 특성, 인접 화면에 맞추어 다시 분류한다. + 각 presentation framework 들은 필요한 service framework 만을 참조한다.
- ui단에서 쓰일 공통 컴포넌트들은 미리 정의 되어 재사용 되어야 한다.
- 서비스 내에서 도메인은 구현을 위한 세부사항을 제외하고 모델링 되어야한다.


### 서비스간 협업 방식
- 서비스 별 필요한 고유 entity를 정의한다.
- usecase에 정의되어있는 도메인로직(엄무규칙, 정책) 등을 도메인 모델로 이동시킨다(aggregate 정의 등)
- 서비스간 직접 + 동기적인 메세징이 필요한 경우 proxy 인터페이스를 정의하고 이는 앱 타겟에서 연결해준다
- 도메인 이벤트는 비동기적으로 전달 + 처리되며 각각의 서비스에서 이벤트 메세지 퍼블리셔 / 핸들러를 인터페이스를 정의하고 도메인 이벤트 브로커? 프레임 워크나 앱 타겟에서 연결해준다. -> 이벤트 정의는 고민 필요
