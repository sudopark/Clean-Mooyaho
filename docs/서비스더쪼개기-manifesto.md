## 최초안

### 개선할 사항
- 현재 UI단은 대표 피처별로 분리되어 있지만 Domain, DataStore의 경우 점점 비대해짐을 피할수은 없다
- 저수준의 UI 프레임 워크와 datastore가 고수준인 domain 만바라보는 구조이지만 거대한 domain framework의 의존이 크다
- domain의 특정 usecase 들은 이미 복잡도가 매우 높다 -> 더 작은 인스턴스들의 협업관계로 나누어야 할 필요가 있음
- datastore내 repository들의 구현(local or remote)의 복잡도가 매우 높다, 데이터베이스 스위칭 로직이 매우 복잡하다, local을 사용하는 경우 repository-local-dataModelStorage로 이어지는 스파게티 코드가 심하다
- 그래도 대부분의 vm들의 역할들은 usecase로 옮겨가져 있어 어느정도 복잡도가 해소되었다.
- 별도 서비스간 entity의 의존도가 높다(각 특성에 따라 정의되어있지 않음)
- presentation layer에 속한 컴포넌트들의 접근제한자가 불필요하게 public이다 -> 프레임워크별 빌드속도 최적화 저하
- 조회, 아이템의 속성 변경 등의 로직들이 앱의 구현에 필요한 세부사항 객체들 위주로 구현되어있다 -> 도메인 모델이 아님

### 방향
- domain을 비즈니스 능력(서비스 특성)에 맞추어 여러 서비스로 나눈다.
- 각 서비스는 별도의 저장소를 지닐 수 있다 -> 서로 각자 다른 remote, local 구현
- 각 서비스는 필요한 고유 entity를 정의한다.
- 각각의 서비스는 직접적으로 참조하지 않고 느슨한 협업 관계를 유지한다.
- 앱 타겟에 있는 ui 로직들을 포함하여 presentation layer간 분류를 화면 특성, 인접 화면에 맞추어 다시 분류한다. + 각 presentation framework 들은 필요한 service framework 만을 참조한다.
- ui단에서 쓰일 공통 컴포넌트들은 미리 정의 되어 재사용 되어야 한다.
- 서비스 내에서 도메인은 구현을 위한 세부사항을 제외하고 모델링 되어야한다.


### 서비스간 협업 방식
- 서비스 별 필요한 고유 entity를 정의한다.
- usecase에 정의되어있는 도메인로직(엄무규칙, 정책) 등을 도메인 모델로 이동시킨다(aggregate 정의 등)
- 서비스간 직접 + 동기적인 메세징이 필요한 경우 proxy 인터페이스를 정의하고 이는 앱 타겟에서 연결해준다
- 도메인 이벤트는 비동기적으로 전달 + 처리되며 각각의 서비스에서 이벤트 메세지 퍼블리셔 / 핸들러를 인터페이스를 정의하고 도메인 이벤트 브로커? 프레임 워크나 앱 타겟에서 연결해준다. -> 이벤트 정의는 고민 필요

## 수정안

### 제한1: 클라이언트에서 도메인의 성격
- 클라에서 비즈니스 업무규칙을 구현할 일이 있나 -> 순수 도메인을 구현시 이 방식이 효율적인가
ex) ReadingList 구현 관련
```
https://github.com/sudopark/Clean-Mooyaho/commit/34d1522546c6320625dcde1120e50150170bc538
1. 읽기목록이라는 ReadingList라는객체의 patch 성격으로 수정하는 경우가 있다 생각해보자
2. 순수 도메인영역에서 이를 수정하기 위해서는 Service에서 리스트 데이터를 조회하여 관리 객체에게 수정하려는 리스트를 수정 요청과 함께 전달해줘야한다.
3. 그 뒤 서비스는 수정된 리스트를 반환받고 이를 저장한다 => 데이터 정합성을 클라에서 맞추는게 올바른가 + 적절한가 
```
- 조회의 경우는 말할필요도 없다
- > 결국 서비스의 구현이 제일 중요해지며 대부분의 서비스가 트렌젝션 스크립 패턴으로 구현될수밖에 없다

### 제한2: 서비스의 성격
- 서비스 프레임워크의 존재 -> 단순 프레임워크만 분리되는 서비스의 구조는 앱클라에서 오히려 비료율적이다(독자적으로 운영되는 서비스라기보단 코드분리 성격이 더 강하다)
- 서비스간, 서비스-유스케이스간 통신 방식이 매우 비효율적이다
- 여러 서비스와 이들을 조합해서 사용하는 유스케이스 프레임워크를(어플리케이션 레이어) 만든다고 생각해보자, 이 경우에 유스케이스들은 서비스들을 참조하게된다(통신 인터페이스 및 dto)
- > 이 경우 앱 전반적인 헥사고날 구조가 깨지게된다, 동시에 클라에서 구현되는 서비스들의 내부구현상 헥사고날 구조는 매우 비효율적이게된다 => 비효율적이고 얻을 수 있는 이점이 없음

### 해결방법
- 지금의 프레젠테이션 -> 도메인 <- 데이터 스토어 관계를 유지한다
- 도메인에 위치한 엔티티 및 유스케이스들은 적절한지, 너무 많은 책임이 있지는 않은지 검토하여 다시 모델링한다.
- 레파지토리는 로컬, 리모트용 인터페이스를 분리해서 제공하고 이를 사용하는 분기로직 책임을 usecase로 이동시킨다, 로컬, 리모트별로 별도로 구현을 다른 타입으로 하여도 괜찮을듯
- 대신 레파지토리의 구현을 단순화한다 -> 로컬 및 리모트의 구현을 제네릭하게 바꿀수있으면 바꾸고 + 특이 케이시들은 제거
- 현재 기본구현이 있는 프로토콜들의 합성으로 되어있는 레퍼지토리들의 구현을 모두 별도 구현체로 분리하고, 하나의 DataStore 프레임워크에서 별도 프레임워크로 분리해 도메인에 있는 레파지토리의 구현체를 제공한다.
